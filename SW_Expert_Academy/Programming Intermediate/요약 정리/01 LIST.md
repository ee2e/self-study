# 01 LIST

## 1. 알고리즘

### 알고리즘 개요

#### 알고리즘이란?

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
  1. 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
  2. 어떠한 문제를 해결하기 위한 절차

#### 알고리즘 표현법

- 슈도코드 : 특정 프로그래밍 언어의 문법을 따라 쓰여진 것이 아니라, 일반적인 언어로 코드를 흉내내어 알고리즘을 써놓은 코드
  - 의사 코드로 흉내만 내는 코드
  - 실제적인 프로그래밍 언어로 작성된 코드처럼 컴퓨터에서 실행할 수 없음
  - 특정 언어로 프로그램을 작성하기 전에 알고리즘을 대략적으로 모델링하는데에 쓰임
- 순서도 : 프로그램이나 작업의 진행 흐름을 순서에 따라 여러 가지 기호나 문자로 나타낸 도표
  - 흐름도, 프로그램의 논리적인 흐름, 데이터의 처리 과정을 표현하는 데 사용
  - 프로그램을 자성하기 전에 프로그램의 전체적인 흐름과 과정 파악을 위해 필수적으로 거쳐야 하는 작업



### 알고리즘의 성능 분석

#### 무엇이 좋은 알고리즘인가?

- 정확성 : 얼마나 정확하게 동작하는가?
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가?
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가?
- 단순성 : 얼마나 단순한가?
- 최적성 : 더 이상 개선할 여지 없이 최적화되었는가?

#### 알고리즘의 성능 분석 필요

- 많은 문제에서 알고리즘의 성능 분석 기준으로 알고리즘의 작업량을 비교
  - 실제 걸리는 시간을 측정
  - 실행되는 명령문의 개수를 계산

#### 시간 복잡도 = 빅-오(O) 표기법

- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시

- 계수(Coefficient)는 생략하여 표시

  ex) O(2n+1) = O(2n) = O(n)

  ​	  O(2n<sup>2</sup>+10n+100) = O(n<sup>2</sup>)

  ​	  O(4) = O(1)

- 요소 수가 증가함에 따라 각기 다른 시간복잡도의 알고리즘은 아래와 같은 연산 수를 보임

---





## 2. List

### Python 소개

- 파이썬(Python) : 1991년 귀도 반 로섬이 개발한 프로그래밍 언어

  1. 인터프리어 언어로 독립적인 플랫폼
  2. 객체지향
  3. 파이썬2와 파이썬3 버전이 배포중, 파이썬 재단은 파이썬3을 권장

- 프로그램 실행 속도에 관심 집중 : 하드웨어 성능이 좋지 않던 시기에는 프로그램의 실행 속도가 크게 차이가 남 -> 실행 속도가 느린 파이썬이 주목 받지 못함

- 개발 시간 단축에 관심 집중 : 하드웨어의 성능 개선으로 실행 속도의 차이가 크지 않음 -> 많은 개발자들이 파이썬을 사용함

- Yes, Python is Slow, and I Don't Care. A rant on sacrificing performance for productivity.

- 변수

  1. 파이썬에서는 모든 자료는 객체

     - Java나 C에서 사용되는 기본형 타입 변수도 파이썬에서는 객체

  2. 변수의 선언은 따로 없음

     - 변수에 값을 초기화 시 변수가 메모리에 생성 

       -> 하나의 변수에 다른 타입의 값을 변수에 저장할 수 있음

- 자료형

  |  타입  |  type()  |
  | :----: | :------: |
  |  정수  |   int    |
  |  실수  |  float   |
  | 복소수 | complex  |
  |  부울  |   bool   |
  | 문자열 |   str    |
  |  튜플  |  tuple   |
  | 리스트 |   list   |
  |  사전  |   dict   |
  |   셋   |   set    |
  |  None  | NoneType |
  |  함수  | function |
  | 클래스 | 클래스명 |

  - 다수의 데이터를 저장할 수 있는 컨테이너

    |            | 기호 | 순서 |            중복            | 데이터변경 |                      비고                      |
    | :--------: | ---- | :--: | :------------------------: | :--------: | :--------------------------------------------: |
    |   tuple    | ()   |  O   |             O              |     X      | 수의 나열은 tuple로 인식<br>packing, unpacking |
    |    list    | []   |  O   |             O              |     O      |                                                |
    | dictionary | {}   |  X   | 키의 중복 X<br>값의 중복 O |     O      |     키 : 값의 구조로 저장 키는 불변 객체만     |
    |    set     | {}   |  X   |             X              |     O      |             불변 객체만 저장 가능              |



### List 소개

- 배열(List) : 같은 타입 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

  - 파이썬의 리스트는 C나 Java에서의 배열과 비슷한 자료구조

    변수를 사용하여 리스트로 바꾸어 사용함



### List 사용법

- 파이썬의 변수

  - 별도의 선언 방법이 없으며 변수에 처음 값을 할당할 때 생성

    값을 초기화하기 전에, 변수를 미리 만들어 두어야 할 경우 -> 공백 리스트 생성

    ​	방법1 : `num=[]` / 방법2 : `arr=list()`

- 배열과 리스트의 차이점

  |        |             배열              |             리스트             |
  | :----: | :---------------------------: | :----------------------------: |
  | 데이터 |   같은 타입의 데이터만 저장   | 다양한 데이터를 저장할 수 있음 |
  |  크기  | 처음 지정한 후 변경할 수 없음 |   가변적으로 변경할 수 있음    |

- 2차원 리스트의 개념

  `arr = [[1,2],[3,4],[5,6]]`

- 시퀀스(Sequence) 자료형

  - 순서가 존재함으로, 인덱싱과 슬라이싱의 연산 모두 적용가능
    - 인덱싱(Indexing) : 시퀀스 자료형에서 하나의 요소를 인덱스 연산자를 통하여 참조하는 것
    - 슬라이싱(Slicing) : 시퀀스 자료형의 원하는 범위를 선택하는 연산

- 함수와 연산

  |   함수   |               설명                |              예시               |    결과     |
  | :------: | :-------------------------------: | :-----------------------------: | :---------: |
  |  len()   |             원소 개수             |          len([2,3,4])           |      3      |
  |    +     |            시퀀스 연결            |         [1,2,3] + [4,5]         | [1,2,3,4,5] |
  |    *     |               반복                |            [1,2] * 2            |  [1,2,1,2]  |
  |    in    |            소속하는지             |          2 in [1,2,3]           |    True     |
  |  not in  |         소속하지 않는지지         |        2 not in [1,2,3]         |    False    |
  |  min()   |          원소 중 최소값           |          min([1,2,3])           |      1      |
  |  max()   |          원소 중 최대값           |          max([1,2,3])           |      3      |
  | sorted() |        정렬된 리스트 반환         | a = [3,1,2]<br>print(sorted(a)) |   [1,2,3]   |
  | append() |         리스트 끝에 추가          |    a = [1,2]<br>a.append(3)     |   [1,2,3]   |
  | insert() |          해당위치에 삽입          |  a = [3,4,5]<br>a.insert(1,9)   |  [3,9,4,5]  |
  |  pop()   |       특정 index 항목 삭제        |     a = [3,4,5]<br>a.pop(1)     |    [3,5]    |
  | remove() | 특정 값을 삭제<br>(첫번째 요소만) |   a = [3,4,5]<br>a.remove(4)    |    [3,5]    |
  | count()  |        일치하는 값의 개수         | a = [9,4,4,9,5,9]<br>a.count(9) |      3      |

- 리스트 함축(List Comprehension)
  - 수학에서 집합을 정의하는 표현식과 유사함





## 3. Exhaustive Search

### 완전 검색 소개

#### 완전검색(Exhaustive Search)

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
  1. Brute-force 혹은 Generate-and-Test 기법이라고도 불림
  2. 모든 경우의 수를 테스트한 후, 최종 해법을 도출함
  3. 일반적으로 경우의 수가 상대적으로 작을 때 유용함
  4. 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
  5. 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함

#### 순열(Permutation)

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
  1. 서로 다른 n개 중 r개를 택하는 순열 : nPr
  2. nPr은 다음과 같은 식이 성립 : nPr = n\*(n-1)*(n-2)\*...\*(n-r+1)
  3. nPn = n!이라고 표기하며 Factorial이라 부름





## 4. Greedy Algorithm

### 탐욕 알고리즘이란?

#### 탐욕 알고리즘(Greedy Algorithm)

- 최적 해를 구하는데 사용되는 근시안적인 방법
  1. 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달함
  2. 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그것들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없음
  3. 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 됨
- 탐욕 알고리즘의 수행 과정
  - 해 선택
    - 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가함
  - 실행 가능성 검사 
    - 새로운 부분 해 집합이 실행 가능한지를 확인
    - 곧, 문제의 제약 조건을 위반하지 않는지를 검사함
  - 해 검사
    - 새로운 부분 해 집합이 문제의 해가 되는지를 확인
    - 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작함





## 5. Sort

### 정렬 개요

#### 정렬(Sort)이란?

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순: ascending), 혹은 그 반대의 순서대로(내림차순: descending) 재배열 하는 것
  - 키란 자료를 정렬하는 기준이 되는 특정 값
- 대표적인 정렬 방식의 종류
  - 버블 정렬(Bubble Sort)
  - 카운팅 정렬(Counting Sort)
  - 선택 정렬(Selection Sort)
  - 퀵 정렬(Quick Sort)
  - 삽입 정렬(Insertion Sort)
  - 병합 정렬(Merge Sort)

### 버블 정렬(Bubble Sort)

- 인접한 두 개의 원소를 비교하여 자리를 계속 교환하는 방식
- 정렬 과정
  - 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  - 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨
  - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품모양 같아서 버블 정렬이라고 함
- 시간 복잡도 = O(n<sup>2</sup>)

### 카운팅 정렬(Counting Sort)

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- 정렬 과정
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 / 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 리스트를 사용하기 때문임
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- 시간 복잡도 = O(n+k) : n은 리스트의 개수, k는 정수의 최대값