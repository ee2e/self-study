# 1과목 소프트웨어 설계

## 1장 요구사항 확인

### 001 소프트웨어 생명 주기

#### 1. 소프트웨어 생명 주기
- 소프트웨어 개발과정을 단계별로 나눈 것
#### 2. 폭포수 모형
- 각 단계를 한번씩만 거침(되돌릴 수 없음)
- 단계별 철저한 검증 필요 / 매뉴얼 작성 필요
#### 3. 프로토타입 모형
- 기능적 인터페이스 중심으로 견본 개발 후 최종 개발
- 추후 발견 될 오류 방지
- 폭포수 모형의 단점을 보완하기 위한 모형
#### 4. 나선형 모형(Spiral Model)
- 계획 - 분석(검증) - 개발 - 평가(오류방지)의 단계를 반복
- 폭포수와 프로토타입의 장점을 흡수하여 점진적 개발
- 대규모 소프트웨어 개발에 용이
- 정밀하며, 유지보수 과정이 필요 없음
#### 5. 애자일 모형
- 요구사항 반영 및 고객과의 의사소통 빈도를 높이는 것이 목표
- 여러 개발 방법을 아우르는 모델



### 002 스크럼(Scrum) 기법

#### 1. 스크럼의 개요

- 팀 중심, 제품 책임자(PO), 스크럼 마스터(SM), 개발팀(DT)으로 구성

- 제품 책임자(PO)
  - 의사 결정자
  - 백로그의 우선순위 지정

- 스크럼 마스터(SM)
  - 일일 회의 주관
  - 개발 가이드

- 개발팀(DT)
  - 개발자 뿐 아니라 디자이너, 테스터 등 모든 인원

#### 5. 스크럼 개발 프로세스

- 제품 백로그 : 요구사항을 우선순위에 따라 모아놓은 목록
- 스프린트 계획 회의 : 스프린트 일정 수립, 개발자 별로 스프린트 백로그 작성
- 스프린트 : 할 일, 진행 중, 완료
- 일일 스크럼 회의 : 스크럼 마스터 주도, 소멸차트 활용
- 스프린트 검토 회의 : 주별, 제품 책임자 주도, 백로그 업데이트
- 스프린트 회고 : 지난 일정 되돌아보기, 개선점 찾기



### 003 XP(eXtreme Programming) 기법

#### 1. XP

- 짧고 반복적인 개발 주기
- 고객의 적극적 참여를 통한 가시성 향상
- 소규모 인원의 개발 프로젝트에 효과적
- XP의 5가지 핵심가치 : 피드백, 존중, 용기, 단순화, 소통 (피존용단소)

#### 2. XP 개발 프로세스

- 사용자 스토리 : 고객의 요구사항
- 릴리즈 계획 수립 : 부분과 전체의 개발 일정 수립
- 스파이크 : 기술 및 기능 확인을 위해 간단히 만드는 프로그램
- 이터레이션 : 릴리즈를 좀 더 세분화 한 단위
- 승인 검사 : 부분 소프트웨어가 릴리즈 되면 고객이 직접 평가
- 소규모 릴리즈 : 릴리즈 별로 고객의 피드백 확인 가능



### 004 현행 시스템 파악

#### 1. 현행 시스템 파악 절차

- 시스템 개발 범위를 명확하게 설정

#### 2. 시스템 구성 파악

- 기간(주요) 업무와 지원 업무의 주요 기능 파악

#### 3. 시스템 기능 파악

- 주요 기능별 세부 기능들을 계층형으로 표시

#### 4. 시스템 인터페이스 파악

- 주고받는 데이터의 형식, 프로토콜 파악

#### 5. 아키텍처 구성 파악

- 주요 업무 시스템의 구성과 동작원리를 표현

#### 6. 소프트웨어 구성 파악

- 종류 및 라이센스의 적용 방식과 개수

#### 7. 하드웨어 구성 파악

- 서버의 주요 사양과 수량, 이중화 적용 여부

#### 8. 네트워크 구성 파악

- 구성도 작성
- 물리적 위치, 보안 취약점, 유지보수



### 005 개발 기술 환경 파악

#### 1. 개발 기술 환경의 정의

#### 2. 운영체제(OS)

- 시스템 자원 관리, 하드웨어 제어를 위한 인터페이스

#### 3. 운영체제 관련 요구사항 식별 시 고려사항

- 주변 기기 지원 여부

#### 4. 데이터베이스 관리 시스템(DBMS)

- 데이터베이스 관리를 위한 시스템, 종속성과 중복성 해결
- DB에 대한 모든 권한과 책임 있음

#### 5. DBMS 관련 요구사항 식별 시 고려사항

- 상호 호환성, 데이터 이중화

#### 6. 웹 애플리케이션 서버(WAS)

- 동적 컨텐츠 처리를 위한 미들웨어, DB서버와 연동
- 미들웨어 : 서버와 클라이언트 중간에 위치, 클라이언트 대신 복잡한 처리를 하기 위함

#### 7. 웹 어플리케이션 서버(WAS) 관련 요구사항 식별 시 고려사항

- 다양한 옵션

**공통 고려사항** : 가용성, 성능, 비용, 기술지원

#### 8. 오픈 소스 사용에 따른 고려사항

- 라이센스 종류, 기술 지속가능성, 사용자 수



### 006 요구사항 정의, 007 요구사항 분석, 008 요구사항 확인

#### 1. 요구사항 : 서비스에 대한 설명 및 제약조건

- 기능 : 기능 자체
- 비기능 : 기능의 품질, 제약사항
- 사용자 : 쉬운 표현 사용
- 시스템 : 개발자 입장, 전문용어

#### 2. 요구사항 개발 프로세스 : 도출(의사소통) -> 분석 -> 명세(문서화) -> 확인

- 분석 : 타당성 조사, 특정 기준으로 분류
  - 개념 모델링 : 단순화, 개념적 표현, 객체간 관계와 종속성 분석
  - 협상 : (기능과 비기능, 필요자원, 서로)의 요구사항이 충돌하는 경우
  - 정형 분석 : 마지막 단계, 구문과 의미를 갖는 언어 사용, 수학적 기호로 표현
- 확인 : 검증
  - 검토 : 일반적, 고객대표 포함
  - 모델 검증 : 정적(논리적) 검증, 실행안함
  - 프로토타이핑 : 지속적인 프로토타입 작성, 사전 피드백
    - 단점 : 프로토타입에만 집중, 비용부담, 과대평가
  - 인수 테스트 : 사용자 입장에서 요구사항 체크(계획 필요)



### 009 UML(Unified Modeling Language) \*중요*

- 구조적 다이어그램

  | 종류   | 키워드 |
  | ------ | ------ |
  | 클래스 | 구조   |
  |객체|관계|
  |컴포넌트|구현, 인터페이스|
  |배치|구현, 위치|
  |복합체 구조|내부 구조|
  |패키지|그룹|

- 행위 다이어그램

  | 종류 | 키워드 |
  | ---- | ------ |
  |유스케이스|모델링|
  |시퀀스|메시지|
  |커뮤니케이션|메시지 + 연관관계|
  |상태|상태 변화|
  |활동|로직 흐름|
  |상호작용 개요|제어 흐름|
  |타이밍|시간제약|

- Q&A

  - 물리적인 자원의 위치를 표시하는 것으로 구현 단계에서 사용되는 것은?
    - 배치 다이어그램
  - 사물의 종류 중 (구조, 행동, 주해)를 제외한 나머지 하나는?
    - 그룹
  - (시퀀스, 상태, 배치, 활동) 중 동적인 행위를 표현하기 위한 것이 아닌 것은?
    - 배치 다이어그램
  - UML 다이어그램 중, 구현 단계에서 사용하기 적절한 것은?
    - 컴포넌트, 배치
  - 의존, 실체화 관계에서 처럼 일시적인 관계를 표현할 때 사용되는 선은?
    - 점선 화살표
  - 다중도 표현에서 ('다수', '또는')에 해당되는 기호는?
    - 다수 : `*`
    - 또는 : `..`
  - 자동차와 열쇠의 관계를 표현하기 가장 적절한 관계는?
    - 포함 관계

---



## 2장 화면 설계

### 010 사용자 인터페이스

#### 1. 사용자 인터페이스의 3가지 분야 : 제어, 구성, 기능

#### 2. 사용자 인터페이스의 특징

- 만족도에 큰 영향을 끼치기 때문에
- 편리성과 가독성, 이해도를 높인다
- 최소한의 노력으로 원하는 결과를 얻을 수 있도록 한다
- 소프트웨어 아키텍처를 숙지해야 한다.

#### 3. 사용자 인터페이스의 구분

- CLI(텍스트)
- GUI(마우스)
- NUI(말, 행동)

#### 4. 사용자의 인터페이스의 기본 원칙 : 직관, 유효, 학습, 유연

#### 5. 사용자 인터페이스의 설계 지침

- 사용자 중심, 일관성, 단순성, 결과 예측 가능, 표준화, 접근성
- 명확성, 가시성, 오류 발생 해결



### 011 UI 표준 및 지침

- 모든 콘텐츠는 시각적으로 구분 될 수 있도록 설계해야 한다.
- 용도를 정확하게 이해 할 수 있도록 텍스트를 제공해야 한다.
- 웹 서비스에서는 비표준 문법에 대한 확장성은 고려하지 않는다.



### 012 UI 설계 도구

- 표준 및 지침에 따라 UI를 제작하기 위해선 설계도가 필요
- 설계도는 결과물에 대해 미리보기 기능을 함
#### 1.  와이어프레임

- 뼈대(레이아웃) 배치
- 화면단위

#### 2. 목업

- 실제 화면과 유사
- 기능 구현 아님

#### 3. 스토리보드

- 와이어프레임 + 콘텐츠 설명
- 이동경로
- 작업 지침서 활용

#### 4. 프로토 타입

- 인터렉션 적용(동적인 형태)

#### 5. 유스케이스

- 사용자 요구사항(기능적)을 다이어그램 형식으로 문서화
- 각각의 유스케이스에 대한 명세서 작성



### 013 UI 요구사항 확인

#### 1. UI요구사항 요소 확인

- 데이터 : 가장 먼저 확인, 특성 기반 정리
- 기능 : 무엇을 실행하는지? 동사형으로 정리
- 품질 : 품질, 서비스 감성적인 부분
- 제약 : 비용과 데드라인, 규제 등

#### 2. 정황 시나리오 작성

- 6하원칙, 이야기 형식, 완성된 서비스를 상상

#### 3. 요구사항 작성

- 정확 시나리오를 토대로 작성

#### 4. 정리

- 개인 별 인터뷰를 통해 가능한 많은 사람들과 인터뷰를 진행한다
- 인터뷰를 통해 사업적, 기술적인 요구사항을 명확히 한다
- 인터뷰는 리서치를 진행하기 전에 진행해야 효율적이다
- 활동 사항을 정의할 때는 서로 협의를 통해 진행한다
- UI 요구사항 중 가장 먼저 데이터에 대한 정리를 진행한다
- 정황 시나리오는 완성 된 서비스를 상상하며 최대한 구체적으로 작성한다
- 요구사항은 정황 시나리오를 토대로 작성한다



### 014 품질 요구사항

#### 1. 기능성(적절한 기능이 정확하게 + 호환, 보안)

- 적절성, 정확, 상호운용, 보안, 호환

#### 2. 신뢰성(고장이 나도 문제 없어!!)

- 성숙성, 고장허용성, 회복성

#### 3. 사용성(얼마나 쉽고 편한지)

- 이해, 학습, 운용 친밀

#### 4. 효율성(한정된 시간, 자원으로 많은 일 처리)

- 시간 효율성, 자원 효율성

#### 5. 유지 보수성(개선 및 확장)

- 분석, 변경, 시험, 안정

#### 6. 이식성(다른 환경에서 적응)

- 적용, 설치, 대체, 공존



### 015 UI 프로토타입 제작 및 검토

#### 1. UI프로토타입

- 동적인 형태(실제 동작하는 것처럼)의 테스트 모델
- 필수 기능을 포함, 간단하게, 실 사용자 테스트로 기능 검증

#### 2. 장단점

- 이해와 오류발견이 쉽다
- 자원소모, 생략 가능성

#### 3. 종류

- 페이퍼 프로토타입 : (손으로) 저렴, 즉시, 간단
- 디지털 프로토타입 : (SW로) 결과와 비슷, 테스트 및 수정, 어려움

#### 4. 고려사항

- 계획 : 목적 - 환경 - 핵심UI - 인원 - 검증 - 해결 - 가이드
- 작성 : 범위확인 - 목표확인 - 자원확인

#### 5. 제작단계

- 요구사항 분석 - 요구사항 작성(프로토타입) - 사용자 테스트 및 수정 - 사용자 피드백 및 승인(3, 4단계 반복)



### 016 UI 설계서 작성

- 표지 : 프로젝트(시스템)명
- 개정이력 : 초안작성 이후 변경할 때마다 버전 0.1씩 증가
- 요구사항 정의서 : 요구사항 별 적용여부 기록
- 시스템 구조 : 전체 시스템(사용자, 관리자 등)의 구조 설계
- 사이트 맵 : 전체 콘텐츠 메뉴별 구성 + 표 형태로 작성
- 프로세스 정의서 : 사용자 입장에서 작업이 진행되는 순서도
- 화면 설계 : 각 화면별로 표지 + 스토리보드



### 017 유용성 평가, 018 UI 상세 설계, 019 HCI/UX/감성공학

#### 1. 유용성 평가(사용자의 입장에서 얼마나 유용한지)

- 실행차이(기능) : 쉽지 않은 기능, 불필요한 기능, 중복되는 기능, 불편한 순서(선형흐름)
- 결과차이(평가) : 즉각적이지 않은 피드백, 이해하기 어려운 결과, 파악하기 어려운 변화

#### 2. UI 상세 설계

- 시나리오 : 순서도나 계층구조로 작성
- 일반규칙 : 기능, 구조, 인터렉션, 예외처리 (이후 세부기능 정의)
- 기대효과 긍정적인 문장과 단어(완전, 일관, 이해 등)

#### 3. HCI/UX/감성공학

- HCI
  - 편리하고 안전한 시스템을 개발
  - 최적의 사용자 경험(UX)이 최종 목표
- UX
  - 시스템 이용 중 얻게되는 모든 경험
  - 주관적, 심리적, 정황성(상황에 따라)
  - UI(객관적 지표가 있는 편리성과 사용성)와 반대개념
- 감성공학
  - 심리적인, 인간 친화적인 시스템 개발

---



## 3장 애플리케이션 설계

### 020 소프트웨어 아키텍처

#### 1. SW아키텍처

- 뜻 : 기본 구조, 개발 기반
- 역할 : 품질유지, 원칙, 지침
- 모듈 : 부품(나중에 자세히 배움)

#### 2. 기본원리

- 모듈화 : 유지관리에 좋음 (많으면 통합비용 증가, 적으면 개발비용 감소)
- 추상화 : 포괄적 개념, 구체화 하기 위해 필요, 가성비, 구조파악 용이
- 단계적 분해 : 하향식, 추상화의 반복으로 더 많은 단계의 분해 가능
- 정보은닉 : 접근금지, 별도의 인터페이스 사용, 유지보수에 용이

#### 2. 품질 속성

- 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용
- 비즈니스 측면 : 시장 적시성, 비용과 혜택, 시스템 수명
- 아키텍처 측면 : 무결성, 정확성, 완결성, 구축가능성

#### 3. 설계 과정

- 목표 설정
- 시스템 타입
  - 대화형 : 일반적인 어플리케이션
  - 이벤트형 : 외부 신호에 반응하여 작동
  - 변환형 : 데이터 변환
  - 객체 영속형 : 데이터베이스 시스템
- 아키텍처 패턴
  - 미리 만들어 둔 공식
- 시스템 구체화
  - 인터페이스 인터렉션
- 검토



### 021 아키텍처 패턴

- 레이어 패턴
  - 상/하위 계층끼리 상호작용
- 클라이언트-서버 패턴
  - 1:다
  - 항시 대기
  - 독립적 기능
- 파이프-필터 패턴
  - 재사용, 확장, 변환, 동기화, 버퍼링
- 모델-뷰-컨트롤러 패턴
  - 대화형 어플리케이션에 적합
- 피어-투-피어 패턴(P2P)
  - 서버와 클라이언트 역할 변경가능
- 블랙보드
  - 공유 데이터 검색, 인식, 식별



### 022 객체지향(Object-Oriented)

- 절차(구조적)지향 : 프로그램을 하나의 큰 절차(순서)로 구성

- 데이터에는 상수, 변수, 배열, 구조체가 존재하고 기능에는 실행문, 분기문, 반복문, 함수 등이 존재하는데 그 중 데이터의 **구조체**와 기능의 **함수**를 가져와서 클래스(캡슐화)를 생성함
- 클래스의 특징 : 정보은닉, 재사용, 확장(유지보수), 다형성



### 023 모듈

#### 1. 모듈

- 뜻 : 모듈화 된 기능 / 서브루틴, 서브시스템 등으로도 불림
- 독립성 판단 : 약한 결합도와 강한 응집도. 품질과 연관

#### 2. 결합도(결합도 낮은순) - 결합도가 낮을수록 품질 향상 : 모듈간 상호 의존(영향을 미치는) 정도

- 자료(data) : 데이터로 구성
- 스탬프(stamp) : 자료구조로 구성(다른 모듈이 영향을 받음)
- 제어(control) : 다른 모듈에서 흐름을 제어
- 외부(external) : 다른 모듈이 내부 데이터 접근
- 공유(common) : 여러 모듈들이 공통으로 데이터 사용
- 내용(content) : 내부 기능과 데이터 직접 참조

#### 3. 응집도(응집도 강한순) - 응집도가 높을수록 품질 향상 : 정보은닉 개념 확장, 내부 요소들끼리 관련 정도

- 기능(Functional) : 단일 문제 - 단일 기능
- 순차(sequential) : 이전 모듈 추력 -> 다음 모듈 입력
- 통신(communication) : 동일 입출력으로 서로 다른 기능 수행
- 절차(procedural) : 다수의 기능이 순차적으로 진행
- 시간(temporal) : 특정 시간대에 처리되는 기능 모음
- 논리(logical) : 유사한 기능 모음
- 우연(coincidental) : 관련 없는 요소로 구성

#### 4. 팬-인(Fan-In), 팬-아웃(Fan-out)

- 팬 인 : 해당 모듈을 제어하는 들어오는 화살표
- 팬 아웃 : 해당 모듈이 제어하는 나가는 화살표

- 시스템 복잡도를 최적화하려면 인은 높게, 아웃은 낮게 설계



### 024 공통 모듈

#### 1. 공통모듈


|기법|설명|
|-|-|
|정확성(correctness)|필요성|
|명확성(clarity)|비중의적(한가지 의미로 해석되도록)|
|완전성(completeness)|필요한 모든 것|
|일관성(consistency)|충돌방지|
|추적성(traceability)|출처, 관계 파악|

#### 2. 효과적인 모듈 설계 방안

- 결합도 낮 + 응집도 높 = 독립성 = 재사용
- 복잡도 낮 + 중복성 낮 + 입출력 낮 = 품질



### 025 코드

- 순차 코드(Sequence Code) 
  - 1, 2, 3, 4, ...
- 블록 코드(Block Code)
  - 1000~1100 : 총무부, 1101~1200 : 영업부
- 10진 코드(Decimal Code)
  - 1000 : 공학, 1100 : 소프트웨어 공학, 1110 : 소프트웨어 설계
- 그룹 분류 코드(Group Classification Code):
  - 1-01-001 : 본사-총무부-인사계, 2-01-001 : 지사-총무부-인사계
- 연상 코드(Mnemonic Code)
  - TV-40 : 40인치 TV, L-15-220 : 15W 220V의 램프
- 표의 숫자 코드(Significant Digit Code)
  - 120-720-1500 : 두께X폭X길이가 120X720X1500인 강판



### 026 디자인 패턴

#### 1. 생성 패턴 : 캡슐화, 유연성

- 추상 팩토리(Abstract Factory) : 객체 생성코드가 상위 클래스에 존재. 하위(구체화) 클래스가 받아 씀
- 팩토리 메소드(Factory Method) : 객체 생성코드를 하위 클래스에서 구체화. 상위 클래스는 인터페이스만 제공
- 빌더(Builder) : 분리 된 인스턴스를 조합하여 객체 생성
- 프로토타입(Prototype) : 원본 복제, 비용 저렴
- 싱글톤(Singleton) : 클래스 내 인스턴스 하나뿐임을 보장. 동시 참조 불가능

#### 2. 구조 패턴 : 복잡한 구조의 시스템 개발에 필요

- 어댑터(Adapter) : 일치하지 않는 인터페이스 변환
- 브릿지(Bridge) : 추상층(기능)과 구현층(구체화)을 분리하여 독립적 확장
- 컴포지트(Composite) : 트리구조 구성. 단일과 복합 개체 구분없이 다름
- 데코레이터(Decorator) : 기능 추가를 위해 다른 객체를 덧붙임
- 퍼싸드(Facade) : 서브 클래스들의 통합 인터페이스를 제공(wrapper객체)하는 상위 클래스 구성
- 플라이웨이트(Flyweight) : 다수의 유사 객체 생성이 필요할 때 최대한 공유해서 사용(메모리 절약)
- 프록시(Proxy) : 접근이 어려운 객체에 접근할 수 있도록 인터페이스 역할 수행

#### 3. 행위 패턴 : 상호작용, 책임 분배

- 책임 연쇄(Chain of Responsibility) : 둘 이상의 객체가 연결(chain)되어 책임이 차례로 넘어감
- 커맨드(Command) : 명령어 캡슐화(추상과 구체). 로그에 기록
- 인터프리터(Interpreter) : 문법 표현 정의. 맞춤법 검사
- 반복자(Iterator) : 접근이 잦은 객체는 동일한 인터페이스 사용하도록. 순차접근
- 중재자(Mediator) : 복잡한 상호작용 캡슐화
- 메멘토(Memento) : 특정 시점의 상태 객체화. 되돌리기 (ex. Ctrl+Z)
- 옵서버(Observer) : 이벤트 발행과 구독. 상태 변화 전달 (ex. 카톡의 읽음 표시)
- 상태(State) : 상태에 따라 동작을 다르기 (ex. 카톡 알람의 형태)
- 전략(Strategy) : 동일 계열 알고리즘 상호 교환. 독립적 사용
- 템플릿 메소드(Template Method) : 상위에서 인터페이스 정의. 하위에서 구체화(유지보수 쉬워짐)
- 방문자(Visitor) : 처리 기능을 별도의 클래스로 구성

---



## 4장 인터페이스 설계

### 027 시스템 인터페이스 요구사항 분석

#### 1. 시스템 인터페이스 요구사항 구성

- 이름 / 시스템 / 범위(내용) / 방식 / 송신 데이터 / 인터페이스 주기 / 고려사항

#### 2. 시스템 인터페이스 요구사항 분석 절차

- 요구사항 선별
  - 별도의 인터페이스 요구사항 목록 제작
- 자료 준비
  - 시스템 인터페이스 요구사항과 관련된 자료 준비
- 요구사항 분류
  - 기능적 / 비기능적 요구사항으로 분류
- 분석 및 수정
  - 내용을 추가 및 수정 / 세분화 / 우선순위 부여



### 028 인터페이스 요구사항 검증

#### 1. 인터페이스 요구사항 검토 계획 수립

- 기준과 방법, 참여자, 체크리스트, 관련자료, 일정 등

#### 2. 인터페이스 요구사항 검증 방법

- 동료검토, 워크스루(사전검토 후 회의), 인스펙션(검토 전문가)
- 프로토타입 제작 / 관련 툴 사용

#### 3. 인터페이스 요구사항 검증의 주요 항목

- 완전성(누락여부) / 일관성(충돌여부) / 명확성(이해여부)
- 기능성 / 검증 가능성 / 추적 가능성 / 변경 용이성



### 029 인터페이스 시스템 식별

- 개발 시스템 식별 : 개발하고자 하는 시스템 정보
- 내/외부 시스템 식별 : 개발 시스템과 연계할 내/외부 시스템 정보
- 내/외부 시스템 환경 및 관리 주체 식별 : 운용환경(IP, URL, PORT, ...)과 담당자 정보
- 내/외부 시스템 네트워크 연결 정보 식별 : 인증 및 DB정보
- 인터페이스 식별 : 시스템과 연계 할 시스템 사이의 인터페이스 정보
- 인터페이스 시스템 식별 : 송신, 수신 시스템 구분(대외, 내외 구분)



### 030 송/수신 데이터 식별

#### 1. 식별 대상 데이터

- 인터페이스 : 시스템 연계에 필요한 표준 데이터
  - 시스템 공통부 : 연동에 필요함. 인터페이스, 시스템, 코드, 장애 정보 등
  - 거래 공통부 : 송/수신 데이터 처리. 직원, 기기, 매체 정보 등

- 송/수신 데이터 항목
  - 업무 수행에 사용되는 데이터
  - 인터페이스 별로 다름

- 공통 코드
  - 공통적으로 사용하는 코드
  - 상태 코드, 오류 코드, 코드 설명 등

#### 2. 정보 흐름 식별

#### 3. 송/수신 데이터 식별

- 인터페이스 표준 항목 : 교환범위 확인, 인터페이스 표준 항목에 대한 송/수신 데이터 식별
- 코드성 데이터 항목 식별
  - 양쪽 코드가 동일한 경우 : 공통 코드
  - 양쪽 코드가 다른 경우 : 양쪽 코드 정보 필요



### 031 인터페이스 방법 명세화

#### 1. 시스템 연계 기술

- DB link : 기본 제공. DB Link 객체 이용
- API : DB를 읽어오도록 만들어 둔 인터페이스 프로그램
- 연계 솔루션
  - EAI서버와 각 시스템에 설치 된 클라이언트를 통해 데이터 토잇ㄴ
  - 모니터링 및 통제기능
- Socket : 포트할당, 클라이언트와 연결
- Web Servise : SOAP, WSDL, UDDI

#### 2. 인터페이스 통신 유형

- 단방향 : 요청 / 응답 없음
- 동기 : 요청 및 대기 / 응답
- 비동기 : 요청 및 미대기 / 응답

#### 3. 인터페이스 처리 유형

- 실시간 방식 : 즉시 처리 / 예매, 카톡
- 지연 처리 방식 : 처리시간 여유 / 즉시 처리시 비용문제 / 본인인증 문자
- 배치 방식 : 일괄 처리 / 모아뒀다가 대량으로 한번에 / 세금 계산

#### 4. 송/수신 방법 명세화

#### 5. 송/수신 데이터 명세화

#### 6. 오류 식별 및 처리 방안 명세화



### 032 시스템 인터페이스 설계서 작성

- #### 인터페이스 송/수신 방법 및 데이터 명세 산출물 기반



### 033 미들웨어 솔루션 명세

---





# 2과목 소프트웨어 개발

## 1장 데이터 입/출력 구현

### 034 자료 구조
#### 1. 자료 구조의 정의

- 효율적인 프로그램을 작성할 때 가장 우선적인 고려사항은 저장공간의 효율성과 실행시간의 신속성이다.
- 자료 구조에 따라 프로그램의 실행시간이 달라진다.
- 자료 구조는 자료의 표현과 그것과 관련된 연산이다.

#### 2. 자료 구조의 분류

- 선형 구조
  - 배열
  - 선형 리스트
    - 연속 리스트
    - 연결 리스트
  - 스택
  - 큐
  - 데크
- 비선형 구조
  - 트리
  - 그래프

#### 3. 배열(Array)

- 배열은 동일 자료형의 데이터들이 나열되어 있는 구조이다.
- 배열은 데이터 접근과 처리는 첨자와 변수를 이용한다.
- 배열은 삽입/삭제 작업보다 반복적 데이터 처리에 적합하다.
- 배열은 정적인 자료구조로서, 메모리의 낭비가 발생한다.

#### 4. 선형 리스트(Linear List)

- 선형 자료구조는 순서에 따라 데이터에 접근하고 있는 형태이다.

||접근요소|기억공간|삽입/삭제|
|-|-|-|-|
|**연속 리스트**|배열(첨자)|효율|비효율|
|**연결 리스트**|노드(포인터)|비효율|효율|

#### 5. 스택(Stack)

- 스택은 자료의 삽입, 삭제가 한쪽 방향으로만 이루어진다.
- 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출방식이다.
- 공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 overflow가 발생한다.
- 공간이 비워져 있는 상태에서 데이터가 삭제되면 underflow가 발생한다.

#### 6. 큐(Queue)

- 큐는 자료의 삽입, 삭제가 서로 다른 방향에서 이루어진다.
- 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출방식이다.
- Front 포인터는 가장 먼저 삽입 된 데이터의 위치를 기억한다.
- Rear 포인터는 가장 나중에 삽입 된 데이터의 위치를 기억한다.

#### 7. 트리(Tree)

- 트리의 맨 위에 있는 노드는 근 노드(Root Node), 맨 아래에 있는 노드는 단말 노드(Terminal Node) = 잎 노드(Leaf Node)이다.
- 특정 노드의 이전 레벨은 부모 노드(Parent Node), 다음 레벨은 자식 노드(Son Node)이다.
- 동일한 부모노드를 가지고 있는 노드들은 형제 노드(Brother Node, Sibling)이다.
- 노드는 순환을 하지 않는 그래프의 형태이다.



### 035 데이터저장소/데이터베이스/DBMS

#### 1. 데이터 저장소

- 논리 데이터저장소는 데이터 간의 연관성, 제약조건 등을 조직화한 것이다.
- 물리 데이터저장소는 하드웨어적 저장장치에 데이터를 저장한 것이다.

#### 2. 데이터베이스

#### 3. DBMS(DataBase Management System; 데이터베이스 관리 시스템)

- DBMS의 필수 기능은 정의, 조작, 제어기능이다.
- DBMS의 궁극적인 목표는 종속성을 제거하여 독립성을 지키는 것이다.



### 036 데이터 입/출력

#### 1. SQL(Structured Query Language)

- 데이터 정의어(DDL; Data Define Language) : 테이블이나 제약사항 등을 변경할 때 사용
- 데이터 조작어(DML; Data Manipulation Language) : 데이터를 실제로 처리하는데 사용
- 데이터 제어어(DCL; Data Control Language) : 권한, 보안, 백업 등을 정의하는데 사용

#### 2. 트랜잭션(Transaction)

- 한꺼번에 수행되어야 하는 작업(연산)의 단위(모음)
- 트랜잭션 실행 중, 오류가 나면 ROLLBACK을 실행하여 이전 상태로 되돌리고 전부 완료되었다면 COMMIT을 실행하여 결과를 실제로 반영한다



### 037 절차형 SQL

#### 1. 절차형 SQL의 개요

- 절차형 SQL은 블록 구조로 되어 있어 기능별 모듈화가 가능하다.
- 프로시저와 사용자 정의 함수의 차이는 리턴값의 필수 여부이다.

#### 2. 절차형 SQL의 테스트와 디버깅

- 디버깅은 주석과 출력문을 이용하는 것이 일반적이다.

---



## 2장 통합 구현

### 038 단위 모듈 구현

- 단위 모듈을 통합할수록 구현 가능한 기술은 늘어난다.
- 단위 모듈은 독립적인 컴파일이 가능하다.
- 단위 기능 명세화 단계는 추상화, 구조화 캡슐화의 단계를 거친다.
- 모듈 간 통신 방식 구현을 위한 인터페이스의 집합은 IPC이다.
- 단위 모듈 테스트 과정은 시스템 수준의 오류는 잡아낼 수 없다.



### 039 단위 모듈 테스트

#### 1. 테스트 케이스(Test Case)

- 식별자(Identifier) : 식별자, 일련번호
- 테스트 항목(Test Item) : 테스트 대상
- 입력 명세(Input Specification) : 입력 데이터, 조건
- 출력 명세(Output Specification) : 예상 결과
- 환경 설정(Environmental Needs) : 필요 HW/SW
- 특수 절차 요구(Special Procedure Requirement) : 요구 절차
- 의존성 기술(Inter-case Dependencies) : 케이스간 의존성

#### 2. 문제풀이

- 화이트박스 : 소스 코드의 논리적인 경로 테스트

- 블랙박스 : 해당 기능의 작동 여부 테스트

- 통합개발환경 : 개발에 필요한 다양한 툴을 하나의 인터페이스로 통합

- 빌드 도구 : 소스 코드를 소프트웨어로 변환

  

### 040 개발 지원 도구

- 협업 도구는 익숙하지 않거나 이용할 의지가 없으면 협업 도구가 오히려 협업의 방해 요소가 될 수 있다.

---



## 3장 제품 소프트웨어 패키징

### 041 소프트웨어 패키징

- 소프트웨어 패키징은 개발자가 아니라 사용자를 중심으로 진행한다.

- 소스 코드는 향후 관리를 고려하여 모듈화하여 패키징한다.
- 기능 식별(코드작성 - 구분) - 모듈화 - 빌드 진행 - 사용자 환경 분석(환경정의) - 패키지 및 적용 시험(적용테스트) - 패키징 변경 개선 - 배포



### 042 릴리즈 노트 작성

- 릴리즈 노트에 포함되는 내용 : 전체 기능, 서비스, 개선 사항
- 베타 테스트, 사용자의 요구로 수정된 경우 자체 기능 향상과는 다른 별도의 릴리즈 버전으로 출시하고 릴리즈 노트를 작성한다.



### 043 디지털 저작권 관리(DRM)

- 저작권 : 저작물에 대해 저작자가 가지는 배타적(독점적) 권리
- 용량이 큰 프로그램들은 미리 DRM 패키징을 수행한 후 배포한다.
- 클리어링하우스 : 라이센스 관리, 발급, 결제
- DRM관리기술 : 암호화, 키(식별), 정책관리, 인증, 크랙방지



### 044 소프트웨어 설치 매뉴얼 작성

- 목차 및 개요 : 설치 과정(순서) 요약

- 서문 : 문서 이력, 주석(주의, 참고), 구성, 설치 환경

- 기본 항목

  - 설치 화면 : 각 과정의 이미지 첨부
  - 오류 설명 : 주의사항
  - 결과 화면 : 최종화면 공지
  - FAQ : 문제 발생 시 해결방안
  - 점검사항 : 환경, 권한점검
  - 네트워크 : 연결 상태 및 보안
  - 고객지원 : 웹사이트, 연락처
  - 보증 : 준수사항 및 라이센스 정보

  

### 045 소프트웨어 사용자 매뉴얼 작성

- 목차 및 개요 : 설치 과정(순서) 요약

- 서문 : 문서 이력, 주석(주의, 참고), 구성, 설치 환경

- 기본 항목

  - UI 화면 : 각 과정의 이미지 첨부
  - 주요 기능 : 기능에 대한 사용법
  - 설정 : 설정 및 기본 값
  - 장치 연동 : 연동되는 장치
  - 프로파일 : 필수 구동환경
  - 네트워크 : 연결상태 및 보안
  - 고객지원 : 웹사이트, 연락처
  - 보증 : 준수사항 및 라이센스 정보

  

### 046 소프트웨어 버전 등록



### 047 소프트웨어 버전 관리 도구



### 048 빌드 자동화 도구

#### 1. Jenkins

- JAV기반, 오픈소스, 서버기반, 형상관리 도구와 연동 가능
- Web GUI 제공, 분산 빌드(테스트) 가능

#### 2. Gradle

- Groovy기반, 오픈소스, 안드로이드 개발환경
- DSL을 스크립트 언어로 사용, 명령을 모아 태스트 단위로 실행
- 캐시 기능 지원(태스크 재사용 및 공유)으로 속도 향상